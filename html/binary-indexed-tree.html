<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Indexed Tree(Fenwick Tree)</title>
<meta name="author" content="dirtysalt" />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content" class="content">
<h1 class="title">Binary Indexed Tree(Fenwick Tree)</h1>
<p>
<a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/">https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/</a>
</p>

<p>
首先需要了解负数的二进制表示：负数的二进制表示是取反然后+1
</p>

<div class="org-src-container">
<pre class="src src-Python">def binstr(x):
    ss = []
    for i in range(32):
        ss.append((x &gt;&gt; i) &amp; 0x1)
    ss = ss[::-1]
    return ''.join(map(str, ss))

for x in range(10, 16, 2):
    print('bin({:&gt;4s}) = {}'.format(str(x), binstr(x)))
    y = -x
    print('bin({:&gt;4s}) = {}'.format(str(y), binstr(y)))

bin(  10) = 00000000000000000000000000001010
bin( -10) = 11111111111111111111111111110110
bin(  12) = 00000000000000000000000000001100
bin( -12) = 11111111111111111111111111110100
bin(  14) = 00000000000000000000000000001110
bin( -14) = 11111111111111111111111111110010
</pre>
</div>

<p>
然后了解一下index &amp; (-index) 这个操作的含义：找到lsb（找到最低位置的1）
</p>

<div class="org-src-container">
<pre class="src src-Python">print(12 &amp; (-12))
print(binstr(12))

4
00000000000000000000000000001100
</pre>
</div>

<p>
最下面图里面给出的 i &amp; -i 的操作解释很好：
</p>
<ol class="org-ol">
<li>假设i = a 1 0k 的话</li>
<li>~i = (~a) 0 1k</li>
<li>-i = (~a) 1 0k</li>
<li>i &amp; -i = 1 0 0k</li>
</ol>

<hr />

<p>
UPDATE@201809: 最下面的配图可能有助于理解这棵树的组织
</p>

<p>
Binary Indexed Tree实际上进行分段存储，每段长度都是2 ** k - 1，每段里面可以继续拆分：
</p>

<p>
以31为例：31 = 16 + 8 + 4 + 2 + 1. 那么可以分为五段：
</p>
<pre class="example" id="org0665eb9">
1. B[16] = nums[1] + … nums[16]
2. B[24] = nums[17] + … nums[24]
3. B[28] = nums[25] + … nums[28]
4. B[30] = nums[29] + nums[30]
5. B[31] = nums[31]
</pre>
<p>
这个过程就是不断地 index -= (index &amp; -index).
</p>

<p>
然后考虑一下对于nums[index]可能会影响到哪些B呢？假设len(nums) == 32, index = 29. 从上面例子看到
</p>
<pre class="example" id="org1afbe83">
1. B[30] = nums[29] + nums[30]
2. B[32] = nums[1] + … nums[32]
</pre>
<p>
所以这个过程和上面相反，index += (index &amp; -index).
</p>

<div class="org-src-container">
<pre class="src src-Cpp">/*            n  --&gt; No. of elements present in input array.
    BITree[0..n] --&gt; Array that represents Binary Indexed Tree.
    arr[0..n-1]  --&gt; Input array for whic prefix sum is evaluated. */

// Returns sum of arr[0..index]. This function assumes
// that the array is preprocessed and partial sums of
// array elements are stored in BITree[].
int getSum(int BITree[], int index)
{
    int sum = 0; // Iniialize result

    // index in BITree[] is 1 more than the index in arr[]
    index = index + 1;

    // Traverse ancestors of BITree[index]
    while (index&gt;0)
    {
        // Add current element of BITree to sum
        sum += BITree[index];

        // Move index to parent node in getSum View
        index -= index &amp; (-index);
    }
    return sum;
}

// Updates a node in Binary Index Tree (BITree) at given index
// in BITree.  The given value 'val' is added to BITree[i] and
// all of its ancestors in tree.
void updateBIT(int BITree[], int n, int index, int val)
{
    // index in BITree[] is 1 more than the index in arr[]
    index = index + 1;

    // Traverse all ancestors and add 'val'
    while (index &lt;= n)
    {
       // Add 'val' to current node of BI Tree
       BITree[index] += val;

       // Update index to that of parent in update View
       index += index &amp; (-index);
    }
}
</pre>
</div>



<div id="org2dbd111" class="figure">
<p><img src="../images/fenwick-tree-explained.jpg" alt="fenwick-tree-explained.jpg" />
</p>
</div>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://dirtysalt.github.io/html/binary-indexed-tree.html';this.page.identifier = 'binary-indexed-tree.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://dirlt.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
