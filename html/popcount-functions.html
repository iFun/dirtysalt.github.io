<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>几个PopCount函数的实现</title>
<meta name="author" content="dirtysalt" />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content" class="content">
<h1 class="title">几个PopCount函数的实现</h1>
<p>
从 《Beautiful Code》这本书里面看到的一章《The Quest for an Accelerated Population Count》by Henrry S.Warren, Jr.他也是《Hacker Delight》的作者，那本书里面也收集了各种计算技巧，有时间可以拿来翻翻。这篇文章讲的就是如何计算一个整数中bit=1的数量。
</p>

<p>
UPDATE: 文章最后增加了性能对比，包括了 `__builtin_popcount` 的性能。
</p>

<hr />
<p>
最简单的写法是循环32次，稍微好点的做法是提前判断是否为0，但是不知道branch predication的副作用有多大。如果值范围是可以固定的话，那么最好还是使用固定循环次数的写法，这样会更加有时间保证。
</p>

<div class="org-src-container">
<pre class="src src-Cpp">
uint32_t popcount11(uint32_t x) {
    uint32_t ans = 0;
    while (x) {
        ans += x &amp; 0x1;
        x = x &gt;&gt; 1;
    }
    return ans;
}

</pre>
</div>

<p>
UPDATE: 其实可以换成 `x=x&amp;(x-1)` 这样会更快，另外一个方式是使用表查询，效果好像比这个要更好。TABLE大小是 32 * 4 = 128 字节，占用两个cache line(64字节), 在内存访问效率上应该是可以的。
</p>

<div class="org-src-container">
<pre class="src src-Cpp">/*
data = []
for i in range(0,256,8):
    value = 0
    for j in reversed(range(8)):
        value = (value &lt;&lt; 4) | popcount(i+j)
    data.append(value)
*/

uint32_t TABLE[] = {841031952,  1127363105, 1127363105, 1413694258, 1127363105,
                    1413694258, 1413694258, 1700025411, 1127363105, 1413694258,
                    1413694258, 1700025411, 1413694258, 1700025411, 1700025411,
                    1986356564, 1127363105, 1413694258, 1413694258, 1700025411,
                    1413694258, 1700025411, 1700025411, 1986356564, 1413694258,
                    1700025411, 1700025411, 1986356564, 1700025411, 1986356564,
                    1986356564, 2272687717};

inline uint32_t GET8(unsigned char x) {
    return (TABLE[x &gt;&gt; 3] &gt;&gt; ((x &amp; 0x7) &lt;&lt; 2)) &amp; 0xf;
}

uint32_t popcount01(uint32_t x) {
    return GET8(x &amp; 0xff) + GET8((x &gt;&gt; 8) &amp; 0xff) + GET8((x &gt;&gt; 16) &amp; 0xff) +
           GET8((x &gt;&gt; 24) &amp; 0xff);
}
</pre>
</div>

<hr />
<p>
如果采用分治思想的话，那么可以写成下面这样的代码，好处是没有循环分支，并且指令数量也更少了。
</p>

<div class="org-src-container">
<pre class="src src-Cpp">uint32_t _popcount21(uint32_t x) {
    x = (x &amp; 0x55555555) + ((x &amp; 0xaaaaaaaa) &gt;&gt; 1);
    x = (x &amp; 0x33333333) + ((x &amp; 0xcccccccc) &gt;&gt; 2);
    x = (x &amp; 0x0f0f0f0f) + ((x &amp; 0xf0f0f0f0) &gt;&gt; 4);
    x = (x &amp; 0x00ff00ff) + ((x &amp; 0xff00ff00) &gt;&gt; 8);
    x = (x &amp; 0x0000ffff) + ((x &amp; 0xffff0000) &gt;&gt; 16);
    return x;
}
</pre>
</div>

<p>
上面那个版本，其实和下面这个版本是等价的，好处是涉及到的常量少了，可能指令会更加精简。
</p>

<div class="org-src-container">
<pre class="src src-Cpp">uint32_t popcount21(uint32_t x) {
    x = (x &amp; 0x55555555) + ((x &gt;&gt; 1) &amp; 0x55555555);
    x = (x &amp; 0x33333333) + ((x &gt;&gt; 2) &amp; 0x33333333);
    x = (x &amp; 0x0f0f0f0f) + ((x &gt;&gt; 4) &amp; 0x0f0f0f0f);
    x = (x &amp; 0x00ff00ff) + ((x &gt;&gt; 8) &amp; 0x00ff00ff);
    x = (x &amp; 0x0000ffff) + ((x &gt;&gt; 16) &amp; 0x0000ffff);
    return x;
}
</pre>
</div>

<p>
但是如果仔细观察的话，可以发现从 `x&gt;&gt;4` 这里开始，其实相加就已经不会出现溢出了。因为high bits最多有4个1, low bits最多有4个1，
相加起来最多8个1， 完全可以放在4个bits里面，只不过最后我们需要在取个低位。所以上面的代码可以简化为下面这样
</p>

<div class="org-src-container">
<pre class="src src-Cpp">
uint32_t __popcount21(uint32_t x) {
    // 这里可以假设分别是0，1的情况
    // 如果是11的话，那么11-01 = 10 = 2
    // 10 - 01 = 01 = 1
    // 0x 这个就是 x
    x = x - ((x &gt;&gt; 1) &amp; 0x55555555);
    x = (x &amp; 0x33333333) + ((x &amp; 0xcccccccc) &gt;&gt; 2);
    x = (x + (x &gt;&gt; 4)) &amp; 0x0f0f0f0f;
    x = x + (x &gt;&gt; 8);
    x = x + (x &gt;&gt; 16);
    // 最后一次 low bits 最多 16, 就是 10000
    // high bits 最多 16，也是 10000
    // 所以最多就是 100000
    return x &amp; 0x3f;
}
</pre>
</div>

<hr />

<p>
上面的思想可以扩展到两个数，以及4个数，只要在合适的机会下面将两个数直接相加就好。
</p>

<div class="org-src-container">
<pre class="src src-Cpp">uint32_t popcount22(uint32_t x, uint32_t y) {
    x = (x &amp; 0x55555555) + ((x &amp; 0xaaaaaaaa) &gt;&gt; 1);
    x = (x &amp; 0x33333333) + ((x &amp; 0xcccccccc) &gt;&gt; 2);

    y = (y &amp; 0x55555555) + ((y &amp; 0xaaaaaaaa) &gt;&gt; 1);
    y = (y &amp; 0x33333333) + ((y &amp; 0xcccccccc) &gt;&gt; 2);

    x += y;
    x = (x &amp; 0x0f0f0f0f) + ((x &amp; 0xf0f0f0f0) &gt;&gt; 4);
    x = (x &amp; 0x00ff00ff) + ((x &amp; 0xff00ff00) &gt;&gt; 8);
    x = (x &amp; 0x0000ffff) + ((x &amp; 0xffff0000) &gt;&gt; 16);
    return x;
}

uint32_t popcount24(uint32_t x, uint32_t y, uint32_t a, uint32_t b) {
    x = (x &amp; 0x55555555) + ((x &amp; 0xaaaaaaaa) &gt;&gt; 1);
    y = (y &amp; 0x55555555) + ((y &amp; 0xaaaaaaaa) &gt;&gt; 1);
    a = (a &amp; 0x55555555) + ((a &amp; 0xaaaaaaaa) &gt;&gt; 1);
    b = (b &amp; 0x55555555) + ((b &amp; 0xaaaaaaaa) &gt;&gt; 1);
    x = (x &amp; 0x33333333) + ((x &amp; 0xcccccccc) &gt;&gt; 2);
    y = (y &amp; 0x33333333) + ((y &amp; 0xcccccccc) &gt;&gt; 2);
    a = (a &amp; 0x33333333) + ((a &amp; 0xcccccccc) &gt;&gt; 2);
    b = (b &amp; 0x33333333) + ((b &amp; 0xcccccccc) &gt;&gt; 2);

    x += y;
    a += b;

    x = (x &amp; 0x0f0f0f0f) + ((x &amp; 0xf0f0f0f0) &gt;&gt; 4);
    a = (a &amp; 0x0f0f0f0f) + ((a &amp; 0xf0f0f0f0) &gt;&gt; 4);

    x += a;
    x = (x &amp; 0x00ff00ff) + ((x &amp; 0xff00ff00) &gt;&gt; 8);
    x = (x &amp; 0x0000ffff) + ((x &amp; 0xffff0000) &gt;&gt; 16);
    return x;
}

</pre>
</div>

<p>
有了两个数的popcount求和，可以在上面做出扩展，比如求解 `pop(x) - pop(y)`, 这个式子可以变为 `pop(x) - (32 - pop(~y)) =&gt; pop(x) + pop(~y) - 32`
</p>

<div class="org-src-container">
<pre class="src src-Cpp">// pop(x) - pop(y) = pop(x) - (32 - pop(~y)) = pop(x) + pop(y) - 32
int popDiff(uint32_t x, uint32_t y) {
    x = x - ((x &gt;&gt; 1) &amp; 0x55555555);
    x = (x &amp; 0x33333333) + ((x &gt;&gt; 2) &amp; 0x33333333);
    y = ~y;
    y = y - ((y &gt;&gt; 1) &amp; 0x55555555);
    y = (y &amp; 0x33333333) + ((y &gt;&gt; 2) &amp; 0x33333333);

    x += y;
    x = (x + (x &gt;&gt; 4)) &amp; 0x0f0f0f0f;
    x = (x + (x &gt;&gt; 8));
    x = (x + (x &gt;&gt; 16));
    return x &amp; 0x0000007f - 32;
}
</pre>
</div>

<p>
此外还有个高效实现来比较较两个数的popcount，首先使用bits进行抵消，然后不断地去clear lsb, 然后看谁先为0.
</p>

<div class="org-src-container">
<pre class="src src-Cpp">int popCompare(uint32_t xp, uint32_t yp) {
    unsigned x, y;
    x = xp &amp; ~yp;
    y = yp &amp; ~xp;
    while (1) {
        // if y == 0 then 0
        // else &lt; 0
        if (x == 0) return y | -y;
        if (y == 0) return 1;
        x = x &amp; (x - 1);  // clear lsb
        y = y &amp; (y - 1);
    }
}
</pre>
</div>

<hr />

<p>
还有使用avx512 vpopcount dq指令的实现，因为我的CPU不支持，所以也没有运行，不知道实现是否正确以及效果如何。
</p>

<div class="org-src-container">
<pre class="src src-Cpp">// don't use it. I don't have any cpu support avx512 vpopcnt dq.
// https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html
// g++ mm.cpp -g -W -Wall -mavx512f -mavx512vpopcntdq
uint32_t avx512_vpopcnt(const uint32_t* data, size_t size) {
    uint32_t ans = 0;
    uint64_t start = (uint64_t)data;
    if ((start % 64) != 0) {
        size_t rem = (start % 64) / 4;
        start = (start + 63) / 64 * 64;
        size -= rem;
        FORI(i, rem) ans += popcount21(data[i]);
    }

    const uint8_t* ptr = (uint8_t*)start;
    const uint8_t* end = ptr + size;
    const size_t chunks = size / 64;

    // count using AVX512 registers
    __m512i accumulator = _mm512_setzero_si512();
    for (size_t i = 0; i &lt; chunks; i++, ptr += 64) {
        // Note: a short chain of dependencies, likely unrolling will be needed.
        const __m512i v = _mm512_loadu_si512((const __m512i*)ptr);
        const __m512i p = _mm512_popcnt_epi64(v);

        accumulator = _mm512_add_epi64(accumulator, p);
    }

    // horizontal sum of a register
    uint64_t tmp[8] __attribute__((aligned(64)));
    _mm512_store_si512((__m512i*)tmp, accumulator);

    for (size_t i = 0; i &lt; 8; i++) {
        ans += (uint32_t)tmp[i];
    }

    // popcount the tail
    while (ptr + 4 &lt; end) {
        ans += popcount21(*(uint32_t*)(ptr));
        ptr += 4;
    }
    return ans;
}
</pre>
</div>

<hr />

<p>
下面是性能数据，代码可以看这里 <a href="https://github.com/dirtysalt/codes/tree/master/cc/misc/PopCountTest.cpp">这里</a>
</p>

<ul class="org-ul">
<li>level-2: `__builtin_popcount` 实现</li>
<li>level-1: 打表实现</li>
<li>level0: 循环移位实现</li>
<li>level1,2,4: 分治算法实现</li>
</ul>

<p>
可以看到分治实现比内置实现效率还要高点
</p>

<pre class="example" id="org691c85d">
[level-2] N = 1000, took: 82ms, avg 82ns/N, ans = 443894796
[level-1] N = 1000, took: 106ms, avg 106ns/N, ans = 443894796
[level0] N = 1000, took: 337ms, avg 337ns/N, ans = 443894796
[level1] N = 1000, took: 55ms, avg 55ns/N, ans = 443894796
[level2] N = 1000, took: 37ms, avg 37ns/N, ans = 443894796
[level4] N = 1000, took: 32ms, avg 32ns/N, ans = 443894796
</pre>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://dirtysalt.github.io/html/popcount-functions.html';this.page.identifier = 'popcount-functions.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://dirlt.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
