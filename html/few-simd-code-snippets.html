<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SIMD代码片段分析</title>
<meta name="author" content="dirtysalt" />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content" class="content">
<h1 class="title">SIMD代码片段分析</h1>
<p>
过去一直想收集些自己曾经看过的SIMD代码，觉得这些代码写出来都非常有意思。按照我粗浅的理解，SIMD设计初衷有两个：数据并行化以及减少分支操作。数据并行化这个自不必说，在许多代码下面如果分支预测不好的话，CPU的深度流水线就没有什么用途，造成的misprediction penalty是非常高的。所以在设计和使用SIMD指令的时候，脑子里面一定要将程序设计里面的分支跳转全部忘掉，而是想如何能够使用mask, and, or这些bit操作技巧来得到计算结果。
</p>

<p>
想要知道代码仓库里面是否使用了SIMD，简单的方式就是搜索一些是否使用下面几个头文件
</p>
<ul class="org-ul">
<li>immintrin.h</li>
<li>emmintrin.h</li>
<li>xmmintrin.h</li>
</ul>

<hr />

<p>
下面两个代码片段来自惠新宸老师的博客，链接如下：
</p>
<ul class="org-ul">
<li><a href="https://www.laruence.com/2020/03/09/5412.html">使用SSE2指令集加速字符替换 - 风雪之隅</a></li>
<li><a href="https://www.laruence.com/2020/06/16/5916.html">使用SSE2指令高效实现strtolower - 风雪之隅</a></li>
</ul>

<p>
我把代码复制下来了，博客上有关于这段代码的解释，我就不再这里赘述了。在replace函数里面可以计算替换了多少个字符，
不过这个操作代价有点高，相比替换操作来说 "__builtin_popcount" 这个操作可以占到超过1/2的时间。
</p>

<div class="org-src-container">
<pre class="src src-Cpp">int StringReplace1(char* s, size_t sz, char x, char y) {
    int ans = 0;
    size_t i = 0;
    __m128i search = _mm_set1_epi8(x);
    __m128i delta = _mm_set1_epi8(y - x);
    // unaligned.
    for(;(i+16)&lt;sz;i+=16) {
        __m128i d = _mm_loadu_si128((__m128i*)(s+i));
        __m128i mask = _mm_cmpeq_epi8(d, search);
        int ret = _mm_movemask_epi8(mask);
        if (ret) {
            __m128i add = _mm_and_si128(mask, delta);
            __m128i res = _mm_add_epi8(add, d);
            _mm_storeu_si128((__m128i*)(s+i), res);
            //            ans += __builtin_popcount(ret);
        }
    }
    for(;i&lt;sz;i++) {
        if(s[i] == x) {
            s[i] = y;
            // ans += 1;
        }
    }
    return ans;
}
</pre>
</div>

<p>
测试代码可以看 <a href="https://github.com/dirtysalt/codes/tree/master/cc/misc/StringReplaceTest.cpp">这里</a>, 粘贴一些运行时间。运行时间分为 sparse 和 dense两种模式，sparse触发替换比较少的，dense则是比较多的。可以预测到，dense模式下面分支预测比较好，所以运行时间相比sparse更短。
</p>

<pre class="example" id="orga6c6da9">
YAN007 :: ~/shared » ./a.out
Replace0: mode=sparse, sz=32(0,0) timer=1ms
Replace1: mode=sparse, sz=32(0,0), timer=0ms
Replace0: mode=sparse, sz=128(0,0) timer=5ms
Replace1: mode=sparse, sz=128(0,0), timer=1ms
Replace0: mode=sparse, sz=1024(0,0) timer=42ms
Replace1: mode=sparse, sz=1024(0,0), timer=3ms
Replace0: mode=sparse, sz=10240(0,0) timer=408ms
Replace1: mode=sparse, sz=10240(0,0), timer=28ms
Replace0: mode=sparse, sz=20480(0,0) timer=820ms
Replace1: mode=sparse, sz=20480(0,0), timer=55ms
Replace0: mode=dense, sz=32(0,0) timer=1ms
Replace1: mode=dense, sz=32(0,0), timer=0ms
Replace0: mode=dense, sz=128(0,0) timer=5ms
Replace1: mode=dense, sz=128(0,0), timer=0ms
Replace0: mode=dense, sz=1024(0,0) timer=31ms
Replace1: mode=dense, sz=1024(0,0), timer=3ms
Replace0: mode=dense, sz=10240(0,0) timer=307ms
Replace1: mode=dense, sz=10240(0,0), timer=25ms
Replace0: mode=dense, sz=20480(0,0) timer=617ms
Replace1: mode=dense, sz=20480(0,0), timer=51ms
</pre>

<p>
至于stirng tolowe/upper这个函数，思想就是拿每个字符去和'A', 'Z'比较，如果处于这个中间的话，那么就直接+32. 因为SSE2只有cmpeq和cmpgt, 没有cmpge,cmple，所以在阈值选择上需要+1/-1. 这个函数的效果相比naive的for循环使用，也是好得多的。
</p>

<div class="org-src-container">
<pre class="src src-Cpp">void StringLower1(char* s, size_t sz) {
    size_t i = 0;
    __m128i a = _mm_set1_epi8(64);
    __m128i z = _mm_set1_epi8(91);
    __m128i delta = _mm_set1_epi8(32);
    // unaligned.
    for(;(i+16)&lt;sz;i+=16) {
        __m128i d = _mm_loadu_si128((__m128i*)(s+i));
        __m128i x = _mm_cmpgt_epi8(d, a);
        __m128i y = _mm_cmpgt_epi8(z, d);
        __m128i z = _mm_and_si128(x, y);
        __m128i z2 = _mm_and_si128(z, delta);
        __m128i res = _mm_add_epi8(d, z2);
        _mm_storeu_si128((__m128i*)(s+i), res);
    }
    for(;i&lt;sz;i++) {
        if (s[i] &gt;= 65 &amp;&amp; s[i] &lt;= 90) {
            s[i] += 32;
        }
    }
}
</pre>
</div>

<hr />

<p>
下面两个代码片段来自RapidJSON:
</p>
<ul class="org-ul">
<li><a href="https://github.com/Tencent/rapidjson/blob/master/include/rapidjson/writer.h">https://github.com/Tencent/rapidjson/blob/master/include/rapidjson/writer.h</a></li>
<li><a href="https://github.com/Tencent/rapidjson/blob/master/include/rapidjson/reader.h">https://github.com/Tencent/rapidjson/blob/master/include/rapidjson/reader.h</a></li>
</ul>

<p>
其中writer中的实现是 `ScanWriteUnescapedString` 复制一个字符串直到出现某些字符，而reader中的实现是 `SkipWhitespace_SIMD` 扫描到最近一个空格。两个函数有点类似，reader中使用了比较高级的 `_mm_cmpistri` 指令，所以这里我不选择reader中的函数，只看看writer中的函数。
</p>

<p>
下面是这段代码，稍微有点长，可以分为下面几个部分阅读：
</p>
<ul class="org-ul">
<li>进行16bytes的对齐</li>
<li>处理前面非对齐的部分</li>
<li>处理中间对齐的部分（主要代码）</li>
</ul>

<p>
处理中间对齐的部分是这样的：
</p>
<ul class="org-ul">
<li>t1 = (s == dq('"'))</li>
<li>t2 = (s == bs('\\'))</li>
<li>t3 = (s == space(' '))</li>
<li>x = t1 | t2 | t3</li>
<li>如果x!=0说明有某个字符出现等值了</li>
<li>等值的位置在最低1bit上，可以通过 `__builtin_ffs` 拿到，那么只需要复制1bit之前的字符就行</li>
<li>如果x=0说明没有任何字符出现，那么就可以直接通过 `_mm_storeu_si128` 去复制。</li>
</ul>

<p>
这种操作让人联想到了是否可以使用 SIMD的load/store 来加速memcpy呢？后面可以做做实验。
</p>

<div class="org-src-container">
<pre class="src src-Cpp">template&lt;&gt;
inline bool Writer&lt;StringBuffer&gt;::ScanWriteUnescapedString(StringStream&amp; is, size_t length) {
    if (length &lt; 16)
        return RAPIDJSON_LIKELY(is.Tell() &lt; length);

    if (!RAPIDJSON_LIKELY(is.Tell() &lt; length))
        return false;

    const char* p = is.src_;
    const char* end = is.head_ + length;
    const char* nextAligned = reinterpret_cast&lt;const char*&gt;((reinterpret_cast&lt;size_t&gt;(p) + 15) &amp; static_cast&lt;size_t&gt;(~15));
    const char* endAligned = reinterpret_cast&lt;const char*&gt;(reinterpret_cast&lt;size_t&gt;(end) &amp; static_cast&lt;size_t&gt;(~15));
    if (nextAligned &gt; end)
        return true;

    while (p != nextAligned)
        if (*p &lt; 0x20 || *p == '\"' || *p == '\\') {
            is.src_ = p;
            return RAPIDJSON_LIKELY(is.Tell() &lt; length);
        }
        else
            os_-&gt;PutUnsafe(*p++);

    // The rest of string using SIMD
    static const char dquote[16] = { '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"' };
    static const char bslash[16] = { '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\' };
    static const char space[16]  = { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F };
    const __m128i dq = _mm_loadu_si128(reinterpret_cast&lt;const __m128i *&gt;(&amp;dquote[0]));
    const __m128i bs = _mm_loadu_si128(reinterpret_cast&lt;const __m128i *&gt;(&amp;bslash[0]));
    const __m128i sp = _mm_loadu_si128(reinterpret_cast&lt;const __m128i *&gt;(&amp;space[0]));

    for (; p != endAligned; p += 16) {
        const __m128i s = _mm_load_si128(reinterpret_cast&lt;const __m128i *&gt;(p));
        const __m128i t1 = _mm_cmpeq_epi8(s, dq);
        const __m128i t2 = _mm_cmpeq_epi8(s, bs);
        const __m128i t3 = _mm_cmpeq_epi8(_mm_max_epu8(s, sp), sp); // s &lt; 0x20 &lt;=&gt; max(s, 0x1F) == 0x1F
        const __m128i x = _mm_or_si128(_mm_or_si128(t1, t2), t3);
        unsigned short r = static_cast&lt;unsigned short&gt;(_mm_movemask_epi8(x));
        if (RAPIDJSON_UNLIKELY(r != 0)) {   // some of characters is escaped
            SizeType len;
#ifdef _MSC_VER         // Find the index of first escaped
            unsigned long offset;
            _BitScanForward(&amp;offset, r);
            len = offset;
#else
            len = static_cast&lt;SizeType&gt;(__builtin_ffs(r) - 1);
#endif
            char* q = reinterpret_cast&lt;char*&gt;(os_-&gt;PushUnsafe(len));
            for (size_t i = 0; i &lt; len; i++)
                q[i] = p[i];

            p += len;
            break;
        }
        _mm_storeu_si128(reinterpret_cast&lt;__m128i *&gt;(os_-&gt;PushUnsafe(16)), s);
    }

    is.src_ = p;
    return RAPIDJSON_LIKELY(is.Tell() &lt; length);
}
</pre>
</div>

<hr />
<p>
用 SIMD 来加速memcpy是否可行呢？ 测试代码可以看 <a href="https://github.com/dirtysalt/codes/tree/master/cc/misc/MemcopyTest.cpp">这里</a>, 从结果上看没有 `std::memcpy` 效果好。
</p>

<pre class="example" id="orgfbb263e">
Memcopy: mode=dense, sz=32 timer=2ms
std::memcpy: mode=dense, sz=32, timer=0ms
Memcopy: mode=dense, sz=128 timer=3ms
std::memcpy: mode=dense, sz=128, timer=0ms
Memcopy: mode=dense, sz=1024 timer=7ms
std::memcpy: mode=dense, sz=1024, timer=3ms
Memcopy: mode=dense, sz=10240 timer=50ms
std::memcpy: mode=dense, sz=10240, timer=21ms
Memcopy: mode=dense, sz=20480 timer=170ms
std::memcpy: mode=dense, sz=20480, timer=115ms
</pre>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://dirtysalt.github.io/html/few-simd-code-snippets.html';this.page.identifier = 'few-simd-code-snippets.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://dirlt.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
