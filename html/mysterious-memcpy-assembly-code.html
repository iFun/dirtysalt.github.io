<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>一段奇怪的汇编代码</title>
<meta name="author" content="dirtysalt" />
<meta name="generator" content="Org Mode" />
<link rel="shortcut icon" href="/themes/favicon.ico" /><link rel="stylesheet" type="text/css" href="/themes/simple.css"/></head>
<body>
<div id="content" class="content">
<h1 class="title">一段奇怪的汇编代码</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org305131b">1. 问题出现</a></li>
<li><a href="#orgfe7039a">2. 避免使用vector</a></li>
<li><a href="#org4c2c703">3. 反汇编 0x16181e0 地址</a></li>
<li><a href="#org21279e0">4. 手工使用memcpy</a></li>
</ul>
</div>
</div>

<div id="outline-container-org305131b" class="outline-2">
<h2 id="org305131b"><span class="section-number-2">1.</span> 问题出现</h2>
<div class="outline-text-2" id="text-1">
<p>
下面代码在profile的时候发现，每次循环的时候rax在和奇怪的地址进行比较 0x16181e0
</p>

<div class="org-src-container">
<pre class="src src-Cpp">template &lt;typename T&gt;
inline uint32_t FixedLengthColumnBase&lt;T&gt;::serialize(size_t idx, uint8_t* pos) {
    strings::memcpy_inlined(pos, &amp;_data[idx], sizeof(T));
    return sizeof(T);
}

template &lt;typename T&gt;
void FixedLengthColumnBase&lt;T&gt;::serialize_batch(uint8_t* __restrict__ dst, Buffer&lt;uint32_t&gt;&amp; slice_sizes, size_t chunk_size,
                                               uint32_t max_one_row_size) {
    for (size_t i = 0; i &lt; chunk_size; ++i) {
        slice_sizes[i] += serialize(i, dst + i * max_one_row_size + slice_sizes[i]);
    }
}
</pre>
</div>

<p>
其中rax这里在和某个奇怪的地址进行比较。一个 `奇怪` 的怀疑是判断地址空间是否越界，如果越界的话会去resize空间大小。编译器没有办法确定slice_sizes大小是可以保证不会产生越界情况。
</p>


<div id="org8a75642" class="figure">
<p><img src="../images/Pasted-Image-20231225104949.png" alt="Pasted-Image-20231225104949.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgfe7039a" class="outline-2">
<h2 id="orgfe7039a"><span class="section-number-2">2.</span> 避免使用vector</h2>
<div class="outline-text-2" id="text-2">
<p>
改成下面这样的写法，似乎也不太行，那个奇怪的地址比较还在。不过代码好像清爽不少。
</p>

<div class="org-src-container">
<pre class="src src-Cpp">template &lt;typename T&gt;
inline uint32_t FixedLengthColumnBase&lt;T&gt;::serialize(size_t idx, uint8_t* pos) {
    strings::memcpy_inlined(pos, &amp;_data[idx], sizeof(T));
    return sizeof(T);
}

template &lt;typename T&gt;
void FixedLengthColumnBase&lt;T&gt;::serialize_batch(uint8_t* __restrict__ dst, Buffer&lt;uint32_t&gt;&amp; slice_sizes, size_t chunk_size,
                                               uint32_t max_one_row_size) {
    uint32_t* sizes = slice_sizes.data();
    for (size_t i = 0; i &lt; chunk_size; ++i) {
        sizes[i] += serialize(i, dst + i * max_one_row_size + sizes[i]);
    }
}
</pre>
</div>


<div id="org364a48c" class="figure">
<p><img src="../images/Pasted-Image-20231225104949.png" alt="Pasted-Image-20231225104949.png" />
</p>
</div>
</div>
</div>


<div id="outline-container-org4c2c703" class="outline-2">
<h2 id="org4c2c703"><span class="section-number-2">3.</span> 反汇编 0x16181e0 地址</h2>
<div class="outline-text-2" id="text-3">
<p>
使用命令 `objdump -S &#x2013;start-address=0x16181e0 &#x2013;stop-address=0x16281e0 output/be/lib/starrocks_be` 可以看到这个奇怪地址对应的汇编/代码，就是这个memcpy_inlined，并且是针对长度为1的特定代码。
</p>


<p>
我觉得 `call *rax` 那个部分代码，是编译器认为如果长度不是1的话，那么就会跳转到原始的memcpy实现上。但是纯粹从C++代码来看，这个size是可以确定为 `sizeof(T)` 并且完全不会变的，不太清楚为什么编译器没有做这个优化，或者是完成这个推理。
</p>


<div class="org-src-container">
<pre class="src src-Asm">output/be/lib/starrocks_be:     file format elf64-x86-64


Disassembly of section .text:

00000000016181e0 &lt;_ZN9starrocks10vectorized21FixedLengthColumnBaseIaE9serializeEmPh&gt;:
    // parameter of memcpy is a constant.
    switch (size) {
    case 0:
        break;
    case 1:
        memcpy(dst, src, 1);
 16181e0:       48 8b 47 10             mov    0x10(%rdi),%rax
 16181e4:       0f b6 04 30             movzbl (%rax,%rsi,1),%eax
 16181e8:       88 02                   mov    %al,(%rdx)

template &lt;typename T&gt;
inline uint32_t FixedLengthColumnBase&lt;T&gt;::serialize(size_t idx, uint8_t* pos) {
    strings::memcpy_inlined(pos, &amp;_data[idx], sizeof(T));
    return sizeof(T);
}
 16181ea:       b8 01 00 00 00          mov    $0x1,%eax
 16181ef:       c3                      retq

00000000016181f0 &lt;_ZN9starrocks10vectorized21FixedLengthColumnBaseIaE17serialize_defaultEPh&gt;:
 16181f0:       c6 06 00                movb   $0x0,(%rsi)
template &lt;typename T&gt;
uint32_t FixedLengthColumnBase&lt;T&gt;::serialize_default(uint8_t* pos) {
    ValueType value{};
    strings::memcpy_inlined(pos, &amp;value, sizeof(T));
    return sizeof(T);
}
 16181f3:       b8 01 00 00 00          mov    $0x1,%eax
 16181f8:       c3                      retq
 16181f9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
</pre>
</div>
</div>
</div>

<div id="outline-container-org21279e0" class="outline-2">
<h2 id="org21279e0"><span class="section-number-2">4.</span> 手工使用memcpy</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">
<pre class="src src-Cpp">template &lt;typename T&gt;
void FixedLengthColumnBase&lt;T&gt;::serialize_batch(uint8_t* __restrict__ dst, Buffer&lt;uint32_t&gt;&amp; slice_sizes,
                                               size_t chunk_size, uint32_t max_one_row_size) {
    uint32_t* sizes = slice_sizes.data();
    T* __restrict__ src = _data.data();

    for (size_t i = 0; i &lt; chunk_size; ++i) {
        memcpy(dst + i * max_one_row_size + sizes[i], src + i, sizeof(T));
    }

    for (size_t i = 0; i &lt; chunk_size; i++) {
        sizes[i] += sizeof(T);
    }
}
</pre>
</div>

<p>
可以看到最后生成的代码就没有这个奇怪的比较了。
</p>


<div id="org0e07ef4" class="figure">
<p><img src="../images/Pasted-Image-20231225104933.png" alt="Pasted-Image-20231225104933.png" />
</p>
</div>
</div>
</div>
</div>
<div id="content"><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script>/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/var disqus_config = function () {this.page.url = 'https://dirtysalt.github.io/html/mysterious-memcpy-assembly-code.html';this.page.identifier = 'mysterious-memcpy-assembly-code.html';};(function() {var d = document, s = d.createElement('script');s.src = 'https://dirlt.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><!-- DISQUS END --></div></body>
</html>
